package player;

import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;

public class Minimax {
	private final int availibleThreads = Runtime.getRuntime().availableProcessors();
	private final int wantedDepth = 3; // could be increased during the game
	private BoardEvaluation evaluation;
	private HashMap<Point, Integer> bestMoves;
	private final char myFigure;
	private final char enemyFigure;

	public Minimax(char myFigure, char enemyFigure) {
		evaluation = new BoardEvaluation();
		this.myFigure = myFigure;
		this.enemyFigure = enemyFigure;
	}

	/**
	 * takes the already split lists and starts different threads which are executing the bestMove method / minimax
	 * @param board
	 * @param threadLists list which contains the lists with points for each thread
	 * @return returns best overall move generated by all threads
	 */
	private Point parallelizedSearch(char[][] board, ArrayList<ArrayList<Point>> threadLists) {
		bestMoves = new HashMap<>();
		Thread threads[] = new Thread[availibleThreads];
		for (var i = 0; i < availibleThreads; i++) {
			var list = threadLists.get(i);
			threads[i] = new Thread(()-> {
					bestMove(board, list);
			});
			threads[i].start();
		}
		for(var thread : threads) {
			try {
				thread.join();
			} catch (InterruptedException e) {
				System.out.println("Thread error");
			}
		}
		return sortPoints(bestMoves).get(0); //returns best evaluated point
	}

	private void bestMove(char[][] board, ArrayList<Point> allMoves) {
		var bestMove = new Point();
		var bestValue = Integer.MIN_VALUE;
		for(var move : allMoves) {
			var value = setFigure(board, move, true, wantedDepth);
			if(value > bestValue) {
				bestValue = value;
				bestMove = move;
			}
		}
		bestMoves.put(bestMove, bestValue);
	}
	
	/**
	 * places figure on board, executes minimax algorithm and deletes the figure afterwards
	 * @param board		
	 * @param move 			the point where the figure should be placed
	 * @param isMaximizing
	 * @param depth			current depth
	 * @return				value generated by the minimax algorithm
	 */
	private int setFigure(char [][] board,Point move, boolean isMaximizing, int depth) {
		if(isMaximizing) board[move.x][move.y] = this.myFigure;
		else board[move.x][move.y] = this.enemyFigure;
		var value = minimax(board,!isMaximizing,depth-1);
		board[move.x][move.y] = ' ';
		return value;
	}
	
	private int minimax(char [][] board, boolean isMaximizing, int depth) {
		int bestValue = Integer.MAX_VALUE;
		var allMoves = createPoints(board);
		if(evaluation.hasWon(board)) {
			if(isMaximizing) return Integer.MIN_VALUE;
			else return Integer.MAX_VALUE;
		}
		if(depth == 0) return evaluation.evaluateBoard(board, isMaximizing);
		if(isMaximizing) bestValue = Integer.MIN_VALUE;
		for(var move : allMoves) {
			var value = setFigure(board, move, isMaximizing, depth);
			if(isMaximizing) bestValue = Math.max(value, bestValue);
			else bestValue = Math.max(value, bestValue);
		}
			
		return bestValue;
	}

	/**
	 * 
	 * @param board
	 * @return best point calculated by minimax
	 */
	public Point createMove(char[][] board) {
		var pointList = createPoints(board);
		var evaluatedPoints = evaluation.evaluatePoints(pointList);
		var sortedPoints = sortPoints(evaluatedPoints);
		var threadList = createThreadList(sortedPoints);
		return parallelizedSearch(board, threadList);
	}

	/**
	 * sorts all points from guessed best to worst move
	 * 
	 * @param pointList
	 */
	private ArrayList<Point> sortPoints(HashMap<Point, Integer> evaluatedPoints) {
		// sort
		var sortedList = new ArrayList<Point>();

		return sortedList;
	}

	/**
	 * creates list of points which might be good moves for minimax algorithm
	 * @param board
	 * @return	list of points
	 */
	private ArrayList<Point> createPoints(char[][] board) {
		return null;
	}

	/**
	 * splits points to all threads starting with the best move
	 * 
	 * @param allMoves
	 * @return
	 */
	private ArrayList<ArrayList<Point>> createThreadList(ArrayList<Point> allMoves) {
		var threadList = new ArrayList<ArrayList<Point>>();
		for (var i = 0; i < availibleThreads; i++) {
			threadList.add(new ArrayList<>());
		}
		for (var point : allMoves) {
			var threadNumber = allMoves.indexOf(point) % availibleThreads;
			ArrayList<Point> currentList = threadList.get(threadNumber);
			currentList.add(point);
		}
		return threadList;
	}

	public static void main(String[] args) {
		var minimax = new Minimax('X', 'O');
		var list = new ArrayList<Point>();
		for (int i = 0; i < 24; i++) {
			list.add(new Point((int) (Math.random() * 100), (int) (Math.random() * 100)));
		}
		System.out.println(minimax.createThreadList(list));
	}
}
